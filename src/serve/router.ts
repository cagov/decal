import Router from "@koa/router";
import chalk from "chalk";
import { promises as fs } from "fs";
import { createHtmlHandler } from "./html-handler.js";
import { createDigestHandler } from "./digest-handler.js";
import { Config } from "../config.js";
import { Loader } from "../loader.js";
import { FileReadError } from "../errors.js";

export const createRouter = (config: Config) => {
  const { dirs, collections, loaders, processors } = config;

  const router = new Router();

  /* 
    Meta pages come first.
    These pages are generated by the tool to provide information.
  */

  // The digest file lists all example HTML files found by the tool.
  const digestHandler = createDigestHandler(config);
  router.get(["/", "/index.html"], digestHandler);

  /* 
    We'll then perform initial redirects up-front. 
  */

  const indexRoutes = collections.flatMap((collection) =>
    collection.components.map((component) => component.route)
  );

  // Redirect to corresponding index.html files.
  router.get(["/(.*)/", ...indexRoutes], (ctx) => {
    const index =
      ctx.path.slice(-1) === "/"
        ? `${ctx.path}index.html`
        : `${ctx.path}/index.html`;

    ctx.redirect(index);
  });

  /* 
    Next, we'll match URL routes to corresponding paths on the file system. 
    Each of these routes simply finds the filePath.
    Then the filePath is passed to the next Koa middleware for processing.
  */

  // Collect a list of special folders used within components.
  const magicFolders = ["src", "dist"];

  // Set up the router to handle special folders for the component.
  // This will allow us to use the component's 'src' folder, etc.
  magicFolders.forEach((folder) => {
    // Note the underscores appended to the routes.
    const magicRoute = `/(.*)/_${folder}/(.*)`;

    router.get(magicRoute, async (ctx, next) => {
      const magicPath = ctx.path.replace(`/_${folder}/`, `/${folder}/`);
      ctx.state.filePath = `${dirs.target}${magicPath}`;
      await next();
    });
  });

  // Collect routes for this tool's template folder.
  const templateRoutes = ["/_templates/(.*)", "/(.*)/_templates/(.*)"];

  // Set up the router to load internal templates from this tool.
  // This allows components to load files from the "templates" folder here.
  router.get(templateRoutes, async (ctx, next) => {
    const indexAfterTemplates = ctx.path.indexOf("_templates/") + 11;
    const templateFile = ctx.path.substring(indexAfterTemplates);

    ctx.state.filePath = `${dirs.templates}/serve/${templateFile}`;

    await next();
  });

  // Set up the router to load files from each "examples" folder.
  collections.forEach((collection) => {
    collection.components.forEach((component) => {
      const exampleDir = `${component.dir}/examples`;
      const exampleRoute = `${component.route}/(.*)`;

      router.get(exampleRoute, async (ctx, next) => {
        if (!ctx.state.filePath) {
          const exampleFile = ctx.path.replace(/^.+\//, "");
          ctx.state.filePath = `${exampleDir}/${exampleFile}`;
        }

        await next();
      });
    });
  });

  /*
    Forgive this brief intermission while we set up logging.
  */

  // Set up the router to perform the following actions against all requests.
  const loaderRoutes = Array.from(loaders)
    .map(([id, loader]) => `/(.*)${loader.src.extname}`)
    .sort((a, b) => b.length - a.length);

  router.get(loaderRoutes, async (ctx, next) => {
    // Defer to next middleware.
    await next();

    // After all asset middlewares are complete below, log the request.
    console.log(`${chalk.blue("Loader")}: ${ctx.state.fileLoader}`);
    console.log(`${chalk.blue("Request")}: ${ctx.path}`);
    const logPath = dirs.relative(ctx.state.filePath);
    if (ctx.status === 404) {
      console.log(`${chalk.bgRed("Not found")}: ${logPath}\n`);
    } else if (ctx.status === 500) {
      console.log(`${chalk.bgRed("Errors")}: ${logPath}\n`);
    } else {
      console.log(`${chalk.green("Served")}: ${logPath}\n`);
    }
  });

  /* 
    Now that we have a filePath, we can process assets below. 
  */

  // Handle templated HTML.
  const htmlHandler = createHtmlHandler(config);
  router.get("/(.*).html", htmlHandler);

  // Create a route for the given loader.
  const createLoaderRoute = (route: string, loader: Loader) => {
    const processor = loader.processor;

    if (processor) {
      router.get(route, async (ctx) => {
        if (!ctx.state.fileLoader) {
          await fs
            .readFile(ctx.state.filePath, "utf-8")
            .catch((err) => {
              throw new FileReadError(err.message, err.code, err.path);
            })
            .then((contents) => processor(ctx.state.filePath, contents))
            .then((result) => {
              ctx.state.fileLoader = loader.name;
              ctx.body = result;
              ctx.type = loader.dist.mimeType;
            })
            .catch((err) => {
              ctx.state.fileLoader = loader.name;
              if (err.name === "FileReadError") {
                ctx.body = "Not found";
                ctx.status = 404;
              } else {
                ctx.body = "Errors";
                ctx.status = 500;
              }
            });
        }
      });
    }
  };

  // Create collection-specific routes for each loader in each collection.
  collections.forEach((collection) => {
    collection.loaders
      .sort((a, b) => b.src.extname.length - a.src.extname.length)
      .forEach((loader) => {
        const route = `/${collection.name}/(.*)${loader.src.extname}`;
        createLoaderRoute(route, loader);
      });
  });

  // Create generic, fall-back routes for every loader, across all collections.
  Array.from(loaders)
    .sort((a, b) => b[1].src.extname.length - a[1].src.extname.length)
    .forEach(([id, loader]) => {
      const route = `/(.*)${loader.src.extname}`;
      createLoaderRoute(route, loader);
    });

  // Return the router for consumption by a Koa app.
  return router;
};
